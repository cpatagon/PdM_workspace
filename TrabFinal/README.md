<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"></head><body class="c40 doc-content"><p class="c2 c49 title" id="h.kuw5y5py7t93"><span class="c50"><h1>JUEGO DE DESTREZA Y TIMING CON STM32</h1>
<p class="c22"><span class="c6">(Trabajo Pr&aacute;ctico Final)</span></p><h3 class="c32" id="h.kk6bo6ilm4er"><span class="c31 c27">Alumno: Luis G&oacute;mez</span></h3><h3 class="c32" id="h.2yypqdelrc9d"><span>Plataforma embebida: </span><span class="c27 c44">NUCLEO-STM32F429ZI</span></h3><h3 class="c32 c42 c36" id="h.2yypqdelrc9d-1"><span class="c31 c27"></span></h3><h1 class="c10" id="h.82aknmbf3c9b"><span>Resumen</span></h1><p class="c33"><span class="c6">El objetivo principal de este proyecto es desarrollar un juego electr&oacute;nico que indique al uasuario si ha presionado un pulsador en el momento adecuado. De acuerdo con la precisi&oacute;n del jugador, la respuesta puede ser buena o mala.</span></p><p class="c33"><span class="c6">Para llevar a cabo el trabajo, se utilizar&aacute;n placas comerciales NUCLEO (STM32-F429ZI) y una placa de matriz de LEDs con el circuito integrado MAX7219 (Maxim2023). La informaci&oacute;n de los estados del juego ser&aacute; visualizada en una pantalla de matriz de LEDs, tal como se muestra en la Figura 1.</span></p><p class="c33"><span class="c6">Se emplear&aacute;n los puertos GPIO para la comunicaci&oacute;n con la pantalla, y el pulsador integrado en la misma placa de desarrollo STM32 ser&aacute; utilizado como control de entrada.</span></p><p class="c33"><span class="c6">Una parte fundamental del proyecto ser&aacute; la implementaci&oacute;n de un driver para el prototipo, dise&ntilde;ado en consonancia con las bases conceptuales y la estructura de datos estudiadas en la clase. Este driver se construir&aacute; sobre la capa HAL (Hardware Abstraction Layer, o Capa de Abstracci&oacute;n de Hardware) de STM32. Permitir&aacute; controlar diversas acciones del m&oacute;dulo, como desplegar una imagen o una letra en la pantalla de LEDs.</span></p><p class="c3"><span class="c6"></span></p><h1 class="c10" id="h.2vsidbgihip1"><span class="c41">Perif&eacute;ricos Empleados</span><span class="c37 c27">: </span></h1><p class="c33"><span class="c6">El microcontrolador principal que dirigir&aacute; las acciones para este proyecto es la placa de desarrollo STM32-NUCLEO F429ZI. La informaci&oacute;n se desplegar&aacute; en una pantalla de matriz de LEDs, controlada por el chip MAX7219, que actuar&aacute; como actuador, y se utilizar&aacute; un pulsador de la misma placa de desarrollo como sensor.</span></p><p class="c33"><span class="c6">El MAX7219 es un Circuito Integrado (CI) de visualizaci&oacute;n de c&aacute;todo com&uacute;n compacto, dotado de una entrada/salida serial. Esta funcionalidad facilita la interacci&oacute;n de los microprocesadores con diversos tipos de displays, como displays num&eacute;ricos de 7 segmentos de hasta 8 d&iacute;gitos, displays de barras, o matrices de 64 LEDs individuales. Para este proyecto, se elegir&aacute; la matriz de 64 LEDs individuales, tal como se muestra en la Figura 1, e implementar&aacute; el protocolo de comunicaci&oacute;n a traves de los puertos GPIO.</span></p><p class="c33 c18"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c46"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 557.63px; height: 427.22px;"><img alt="" src="images/image2.png" style="width: 557.63px; height: 427.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c32 c36 c42" id="h.2yypqdelrc9d-2"><span class="c31 c27"></span></h3><h1 class="c10" id="h.dmnut0grbj19"><span class="c37 c27">Diagrama de estado de MEF.</span></h1><p class="c33"><span class="c6">Como se muestra en la Figura 2, que representa el Modelo de Estados Finitos (MEF) del juego, este modelo se inicializa en el estado SET, donde se definir&aacute;n los par&aacute;metros iniciales, como el tiempo de espera en cada estado (denominado t=1 en la figura). Tras esto, se pasa al estado A durante un tiempo (condici&oacute;n &nbsp;t = 1), luego al estado B, y posteriormente al estado C, antes de volver al estado A, y as&iacute; sucesivamente.</span></p><p class="c33"><span class="c6">Este ciclo de transiciones A &rArr; B, B &rArr; C, C &rArr; A continuar&aacute; de manera repetitiva. La &uacute;nica forma de interrumpir este ciclo es a trav&eacute;s de la presi&oacute;n del bot&oacute;n. Dependiendo del estado en el que se encuentre el sistema en ese momento, se pasar&aacute; al estado GOOD o BAD. El estado GOOD se alcanzar&aacute; si el sistema se encuentra en el estado C en el momento de la presi&oacute;n, mientras que el estado BAD ser&aacute; el resultado si el sistema se encuentra en los estados A o B, tal como se indica en el modelo MEF.</span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.17px; height: 414.22px;"><img alt="" src="images/image1.png" style="width: 503.17px; height: 414.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><a id="t.6e94ad8504fe8f9d3c6068e8127cce8b7b61b53a"></a><a id="t.0"></a><table class="c25"><tr class="c43"><td class="c29" colspan="1" rowspan="1"><p class="c22"><span class="c27 c19">Estado</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c22"><span class="c27 c19">Descripci&oacute;n del Estado</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c22"><span class="c19 c27">Acci&oacute;n sobre la Pantalla (Actuador)</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c22"><span class="c8">SET</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Momento en que se muestra &nbsp;el tiempo &quot;delay p&quot; de espera para los estados A, B y C. Tras un tiempo &quot;delay ini&quot;, pasa al estado A y se da inicio a la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra S</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">A</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado B. En caso de presionar el bot&oacute;n, se pasa al estado BAD, indicando que se ha perdido la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra A</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">B</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado C. En caso de presionar el pulsador, se pasa al estado BAD, indicando que se ha perdido la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra B</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">C</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado A. En caso de presionar el bot&oacute;n, se pasa al estado GOOD, indicando que se ha ganado la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra C</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">GOOD</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Estado que indica al jugador que ha ganado la partida. Se mantendr&aacute; durante un tiempo &quot;delay 2&quot; y luego pasar&aacute; al estado SET, donde se comenzar&aacute; nuevamente la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra G</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">BAD</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Estado que indica al jugador que ha perdido la partida. Se mantendr&aacute; durante un tiempo &quot;delay 2&quot; y luego pasar&aacute; al estado SET, donde se comenzar&aacute; nuevamente la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra B</span></p></td></tr></table><h1 class="c10" id="h.uxkwoy6zeovn"><span class="c27 c37">Componentes de hardware</span></h1><p class="c33"><span class="c6">La Figura 3 muestra los componentes de hardware que conforman el proyecto. En la parte superior, se presenta la matriz de LEDs 8x8 junto al Circuito Integrado (CI) MAX7219.</span></p><p class="c33"><span class="c6">M&aacute;s abajo, se ilustra la placa de desarrollo con el CI STM32-F429ZI, sus puertos de entrada/salida y de energ&iacute;a. Adicionalmente, se destaca un bot&oacute;n en la placa, un interruptor que ser&aacute; empleado para controlar los cambios de estado y, por consiguiente, lo que se muestra en la pantalla.</span></p><p class="c33"><span class="c6">Finalmente, se indican las conexiones entre ambos m&oacute;dulos: la de poder como +5V (cable rojo), tierra (GND, cable negro), y los cables dedicados a la comunicaci&oacute;n. Estos &uacute;ltimos incluyen: MOSI-CIN (cable amarillo), Cable Select (CS-CSS, cable verde), y Cable de Datos (MOSI-DIN, cable amarillo). Todo esto se alinea con las especificaciones t&eacute;cnicas del CI MAX7219 y las configuraciones de la placa de desarrollo.</span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 222.93px; height: 460.22px;"><img alt="" src="images/image3.png" style="width: 222.93px; height: 460.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c22"><span class="c6">Figura 3 Diagrama que muestra de manera esquem&aacute;tica los m&oacute;dulos empleados para el proyecto</span></p><h3 class="c32 c36" id="h.2yypqdelrc9d-3"><span><br></span><hr style="page-break-before:always;display:none;"></h3><h1 class="c10" id="h.7n05wo62as87"><span>Definici&oacute;n de los m&oacute;dulos de programa.</span></h1><a id="t.8ad3901016215bf902dfeeb3636af655fad35ee4"></a><a id="t.1"></a><table class="c25"><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c22"><span class="c0">Implementaci&oacute;n</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipos</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_MEF.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_MEF.c</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Gestiona los estados del juego de acuerdo con el Modelo de Estados Finitos (MEF) definido.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_Led.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_Led.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Encargado de enviar los estados actuales de la MEF a la pantalla de LED.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_UART.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_UART.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Facilita el env&iacute;o de eventos al terminal serial (opcional).</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_debounce.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_debounce.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Implementa la verificaci&oacute;n de flancos de se&ntilde;ales para evitar rebotes al utilizar el pulsador.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_delay.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_delay.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Define los intervalos de tiempo durante los cuales se mantendr&aacute; un determinado estado.</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><h1 class="c10" id="h.ejghyi7ruk15"><span>Prototipos de las principales funciones p&uacute;blicas y privadas de cada m&oacute;dulo definido .</span></h1><p class="c3"><span class="c6"></span></p><a id="t.0bc1b2276f5f04e90a6c28a2a7039580bada7cd7"></a><a id="t.2"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_MEF.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c45"><span class="c14">typedef enum{SET, A, B, C, GOOD, BAD} estadoMEF_t;</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Enumeraci&oacute;n de los posibles estados en el Modelo de Estados Finitos (MEF). Puede ser p&uacute;blica o privada.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">-</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void inicializarMEF(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Inicializa el MEF, definiendo los intervalos de tiempo que el sistema permanecer&aacute; en los estados A, B y C.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void actualizarMEF(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Actualiza el estado actual del MEF en funci&oacute;n del tiempo transcurrido, el estado actual y el estado del bot&oacute;n.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">char *Lee_estado();</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Identifica el flanco de la se&ntilde;al, ya sea de subida o bajada, y retorna una descripci&oacute;n correspondiente.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">Puntero a caracteres identificando flanco de subida o bajada</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><a id="t.ba91b60a5b7d04b764e31a19e4145efc2796223d"></a><a id="t.3"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_Led.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">typedef enum{} def_Led_t;</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Enumeraci&oacute;n p&uacute;blica que define las caracter&iacute;sticas de la conexi&oacute;n con la matriz de LED, como el puerto utilizado.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span>-</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void init_LED(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que inicializa los perif&eacute;ricos necesarios para la matriz de LED, preparando la pantalla para su uso.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void update_LED(char);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que actualiza el estado de la matriz de LED seg&uacute;n el car&aacute;cter de entrada, permitiendo la representaci&oacute;n de distintos s&iacute;mbolos.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>char</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><a id="t.b1721f483f29c538cbefa21a64fc7e05b2476f70"></a><a id="t.4"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_UART.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t uartInit();</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n para inicializar la UART. Imprime los par&aacute;metros de configuraci&oacute;n en la terminal serie.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c7">bool_t</span><span>: </span><span class="c7">true</span><span>&nbsp;o </span><span class="c7">false</span><span class="c6">, seg&uacute;n si la conexi&oacute;n se establece o no.</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartSendString(uint8_t * pstring);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n que recibe un puntero a un string para enviar por la UART hasta el car&aacute;cter &#39;\0&#39;. Utiliza la funci&oacute;n </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para transmitir el string.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span class="c6">: puntero al string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartSendStringSize(uint8_t * pstring, uint16_t size)</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que recibe un puntero a un string y un entero con la cantidad de caracteres que debe enviar por la UART. Utiliza </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para enviar.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span>: puntero al string, </span><span class="c7">uint16_t size</span><span class="c6">: tama&ntilde;o del string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartReceiveStringSize(uint8_t * pstring, uint16_t size)</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que recibe un puntero a un string y un entero con la cantidad de caracteres que debe recibir por la UART. Utiliza </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para recibir.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span>: puntero al string, </span><span class="c7">uint16_t size</span><span class="c6">: tama&ntilde;o del string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vacio </span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><h2 class="c47" id="h.5qvvrwkfawvu"><span class="c27 c48"></span></h2><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><a id="t.69f8c30c8e72e92cf7c70ced6e3f8b279e808d81"></a><a id="t.5"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la API_debounce.c</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t readKey();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que lee una variable interna y devuelve si la tecla fue presionada. Si retorna </span><span class="c7">true</span><span>, reinicia el estado de la variable (lo establece en </span><span class="c7">false</span><span class="c6">).</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c7">bool_t</span><span>: estado de la tecla (</span><span class="c7">true</span><span>&nbsp;si fue presionada, </span><span class="c7">false</span><span class="c6">&nbsp;en caso contrario).</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">void debounceFSM_init()</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que inicializa la m&aacute;quina de estados finita (FSM) para el control de rebote, estableciendo el estado inicial.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c11"><span class="c7">void debounceFSM_update(delaydebounce_t* delay)</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que actualiza la FSM para el control de rebote. Lee las entradas, eval&uacute;a las condiciones de transici&oacute;n de acuerdo con el estado actual de la FSM y actualiza el estado y las salidas correspondientes.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">delaydebounce_t* delay</span><span class="c6">: puntero a la instancia de retardo.</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">char *readStatus();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que identifica si se trata de un flanco de subida o de bajada, lo cual es esencial para detectar cambios de estado en una se&ntilde;al.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c3"><span class="c6"></span></p></td></tr></table><p class="c3"><span class="c6"></span></p><h3 class="c32 c36" id="h.jvai5obof5db"><span class="c27 c31"></span></h3><p class="c3"><span class="c6"></span></p><a id="t.584bfb26729d0f55d99d7016df672e19f3de7c78"></a><a id="t.6"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la API_delay.c</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t readKey();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que lee una variable interna y devuelve si la tecla fue presionada. Si retorna </span><span class="c7">true</span><span>, reinicia el estado de la variable (lo establece en </span><span class="c7">false</span><span class="c6">).</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c7">bool_t</span><span>: estado de la tecla (</span><span class="c7">true</span><span>&nbsp;si fue presionada, </span><span class="c7">false</span><span class="c6">&nbsp;en caso contrario).</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">void debounceFSM_init()</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que inicializa la m&aacute;quina de estados finita (FSM) para el control de rebote, estableciendo el estado inicial.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c11"><span class="c14">void debounceFSM_update(delaydebounce_t* delay)</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que actualiza la FSM para el control de rebote. Lee las entradas, eval&uacute;a las condiciones de transici&oacute;n de acuerdo con el estado actual de la FSM y actualiza el estado y las salidas correspondientes.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">delaydebounce_t* delay</span><span class="c6">: puntero a la instancia de retardo.</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p></body></html>
