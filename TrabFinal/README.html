<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=MXVwpSGzOOhqOc5hUWJbBLizfYjsfH9XaeDpmRKYJN5bV0WvE1cEyAoIq5yYZlSc);ol.lst-kix_bywr6hd2odno-0.start{counter-reset:lst-ctn-kix_bywr6hd2odno-0 0}ol.lst-kix_bywr6hd2odno-5{list-style-type:none}ol.lst-kix_bywr6hd2odno-6{list-style-type:none}.lst-kix_bywr6hd2odno-8>li{counter-increment:lst-ctn-kix_bywr6hd2odno-8}ol.lst-kix_bywr6hd2odno-3{list-style-type:none}ol.lst-kix_bywr6hd2odno-3.start{counter-reset:lst-ctn-kix_bywr6hd2odno-3 0}ol.lst-kix_bywr6hd2odno-4{list-style-type:none}.lst-kix_bywr6hd2odno-7>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-7,lower-latin) ". "}ol.lst-kix_bywr6hd2odno-1{list-style-type:none}.lst-kix_bywr6hd2odno-2>li{counter-increment:lst-ctn-kix_bywr6hd2odno-2}ol.lst-kix_bywr6hd2odno-2{list-style-type:none}ol.lst-kix_bywr6hd2odno-0{list-style-type:none}.lst-kix_bywr6hd2odno-6>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-6,decimal) ". "}.lst-kix_bywr6hd2odno-3>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-3,decimal) ". "}.lst-kix_bywr6hd2odno-5>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-5,lower-roman) ". "}ol.lst-kix_bywr6hd2odno-7{list-style-type:none}.lst-kix_bywr6hd2odno-4>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-4,lower-latin) ". "}ol.lst-kix_bywr6hd2odno-8{list-style-type:none}.lst-kix_bywr6hd2odno-1>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-1,lower-latin) ". "}.lst-kix_bywr6hd2odno-2>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-2,lower-roman) ". "}ol.lst-kix_bywr6hd2odno-1.start{counter-reset:lst-ctn-kix_bywr6hd2odno-1 0}ol.lst-kix_bywr6hd2odno-4.start{counter-reset:lst-ctn-kix_bywr6hd2odno-4 0}.lst-kix_bywr6hd2odno-4>li{counter-increment:lst-ctn-kix_bywr6hd2odno-4}.lst-kix_bywr6hd2odno-7>li{counter-increment:lst-ctn-kix_bywr6hd2odno-7}ul.lst-kix_sx13f0mcf23o-1{list-style-type:none}ul.lst-kix_sx13f0mcf23o-0{list-style-type:none}.lst-kix_bywr6hd2odno-0>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-0,decimal) ". "}ul.lst-kix_sx13f0mcf23o-7{list-style-type:none}ul.lst-kix_sx13f0mcf23o-6{list-style-type:none}ul.lst-kix_sx13f0mcf23o-8{list-style-type:none}ul.lst-kix_sx13f0mcf23o-3{list-style-type:none}.lst-kix_sx13f0mcf23o-1>li:before{content:"\0025cb   "}ul.lst-kix_sx13f0mcf23o-2{list-style-type:none}ul.lst-kix_sx13f0mcf23o-5{list-style-type:none}ul.lst-kix_sx13f0mcf23o-4{list-style-type:none}ol.lst-kix_bywr6hd2odno-7.start{counter-reset:lst-ctn-kix_bywr6hd2odno-7 0}.lst-kix_sx13f0mcf23o-2>li:before{content:"\0025a0   "}.lst-kix_sx13f0mcf23o-3>li:before{content:"\0025cf   "}.lst-kix_sx13f0mcf23o-4>li:before{content:"\0025cb   "}.lst-kix_bywr6hd2odno-0>li{counter-increment:lst-ctn-kix_bywr6hd2odno-0}.lst-kix_sx13f0mcf23o-6>li:before{content:"\0025cf   "}.lst-kix_sx13f0mcf23o-7>li:before{content:"\0025cb   "}.lst-kix_bywr6hd2odno-6>li{counter-increment:lst-ctn-kix_bywr6hd2odno-6}.lst-kix_sx13f0mcf23o-5>li:before{content:"\0025a0   "}ol.lst-kix_bywr6hd2odno-5.start{counter-reset:lst-ctn-kix_bywr6hd2odno-5 0}.lst-kix_sx13f0mcf23o-0>li:before{content:"\0025cf   "}.lst-kix_sx13f0mcf23o-8>li:before{content:"\0025a0   "}.lst-kix_bywr6hd2odno-1>li{counter-increment:lst-ctn-kix_bywr6hd2odno-1}.lst-kix_bywr6hd2odno-5>li{counter-increment:lst-ctn-kix_bywr6hd2odno-5}ol.lst-kix_bywr6hd2odno-8.start{counter-reset:lst-ctn-kix_bywr6hd2odno-8 0}ol.lst-kix_bywr6hd2odno-6.start{counter-reset:lst-ctn-kix_bywr6hd2odno-6 0}.lst-kix_bywr6hd2odno-8>li:before{content:"" counter(lst-ctn-kix_bywr6hd2odno-8,lower-roman) ". "}ol.lst-kix_bywr6hd2odno-2.start{counter-reset:lst-ctn-kix_bywr6hd2odno-2 0}.lst-kix_bywr6hd2odno-3>li{counter-increment:lst-ctn-kix_bywr6hd2odno-3}ol{margin:0;padding:0}table td,table th{padding:0}.c38{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:105.8pt;border-top-color:#000000;border-bottom-style:solid}.c17{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:117.8pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:54pt;border-top-color:#000000;border-bottom-style:solid}.c21{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:159.8pt;border-top-color:#000000;border-bottom-style:solid}.c9{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:132.8pt;border-top-color:#000000;border-bottom-style:solid}.c15{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:144.8pt;border-top-color:#000000;border-bottom-style:solid}.c12{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:465pt;border-top-color:#000000;border-bottom-style:solid}.c1{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:306pt;border-top-color:#000000;border-bottom-style:solid}.c39{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:114.8pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:248.2pt;border-top-color:#000000;border-bottom-style:solid}.c23{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:98.2pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:89.2pt;border-top-color:#000000;border-bottom-style:solid}.c30{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;border-left-style:solid;border-bottom-width:0pt;width:98.2pt;border-top-color:#000000;border-bottom-style:solid}.c47{padding-top:10pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify;height:13pt}.c3{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:justify;height:11pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c32{padding-top:8pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}.c10{padding-top:8pt;padding-bottom:10pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:21pt;font-family:"Trebuchet MS";font-style:normal}.c0{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:justify;height:11pt}.c46{color:#ff0000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c28{color:#ff0000;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Trebuchet MS";font-style:normal}.c48{color:#000000;text-decoration:none;vertical-align:baseline;font-size:13pt;font-family:"Trebuchet MS";font-style:normal}.c45{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:justify}.c22{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c31{color:#666666;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Trebuchet MS";font-style:normal}.c5{padding-top:0pt;padding-bottom:10pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c44{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Trebuchet MS";font-style:normal}.c33{padding-top:12pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:justify}.c37{color:#666666;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Trebuchet MS";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c35{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c25{border-spacing:0;border-collapse:collapse;margin-right:auto}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c49{page-break-after:avoid;orphans:2;widows:2}.c7{font-family:"Roboto Mono";color:#188038;font-weight:400}.c14{font-family:"Roboto Mono";color:#188038;font-weight:700}.c40{background-color:#ffffff;max-width:465pt;padding:85pt 45.4pt 28.1pt 85pt}.c43{height:39.8pt}.c26{height:21pt}.c27{font-weight:700}.c18{height:11pt}.c41{font-size:14pt}.c42{margin-left:36pt}.c19{font-size:10pt}.c34{height:54.2pt}.c24{height:0pt}.c36{height:12pt}.title{padding-top:0pt;color:#000000;font-size:21pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}.subtitle{padding-top:0pt;color:#666666;font-size:13pt;padding-bottom:10pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:justify}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:8pt;color:#666666;font-weight:700;font-size:14pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h2{padding-top:10pt;color:#000000;font-weight:700;font-size:13pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h3{padding-top:8pt;color:#666666;font-weight:700;font-size:12pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h4{padding-top:8pt;-webkit-text-decoration-skip:none;color:#666666;text-decoration:underline;font-size:11pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;text-decoration-skip-ink:none;font-family:"Trebuchet MS";orphans:2;widows:2;text-align:justify}h5{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:justify}h6{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:justify}</style></head><body class="c40 doc-content"><p class="c2 c49 title" id="h.kuw5y5py7t93"><span class="c50">JUEGO DE DESTREZA Y TIMING CON STM32</span></p><p class="c22"><span class="c6">(Trabajo Pr&aacute;ctico Final)</span></p><h3 class="c32" id="h.kk6bo6ilm4er"><span class="c31 c27">Alumno: Luis G&oacute;mez</span></h3><h3 class="c32" id="h.2yypqdelrc9d"><span>Plataforma embebida: </span><span class="c27 c44">NUCLEO-STM32F429ZI</span></h3><h3 class="c32 c42 c36" id="h.2yypqdelrc9d-1"><span class="c31 c27"></span></h3><h1 class="c10" id="h.82aknmbf3c9b"><span>Resumen</span></h1><p class="c33"><span class="c6">El objetivo principal de este proyecto es desarrollar un juego electr&oacute;nico que indique al uasuario si ha presionado un pulsador en el momento adecuado. De acuerdo con la precisi&oacute;n del jugador, la respuesta puede ser buena o mala.</span></p><p class="c33"><span class="c6">Para llevar a cabo el trabajo, se utilizar&aacute;n placas comerciales NUCLEO (STM32-F429ZI) y una placa de matriz de LEDs con el circuito integrado MAX7219 (Maxim2023). La informaci&oacute;n de los estados del juego ser&aacute; visualizada en una pantalla de matriz de LEDs, tal como se muestra en la Figura 1.</span></p><p class="c33"><span class="c6">Se emplear&aacute;n los puertos GPIO para la comunicaci&oacute;n con la pantalla, y el pulsador integrado en la misma placa de desarrollo STM32 ser&aacute; utilizado como control de entrada.</span></p><p class="c33"><span class="c6">Una parte fundamental del proyecto ser&aacute; la implementaci&oacute;n de un driver para el prototipo, dise&ntilde;ado en consonancia con las bases conceptuales y la estructura de datos estudiadas en la clase. Este driver se construir&aacute; sobre la capa HAL (Hardware Abstraction Layer, o Capa de Abstracci&oacute;n de Hardware) de STM32. Permitir&aacute; controlar diversas acciones del m&oacute;dulo, como desplegar una imagen o una letra en la pantalla de LEDs.</span></p><p class="c3"><span class="c6"></span></p><h1 class="c10" id="h.2vsidbgihip1"><span class="c41">Perif&eacute;ricos Empleados</span><span class="c37 c27">: </span></h1><p class="c33"><span class="c6">El microcontrolador principal que dirigir&aacute; las acciones para este proyecto es la placa de desarrollo STM32-NUCLEO F429ZI. La informaci&oacute;n se desplegar&aacute; en una pantalla de matriz de LEDs, controlada por el chip MAX7219, que actuar&aacute; como actuador, y se utilizar&aacute; un pulsador de la misma placa de desarrollo como sensor.</span></p><p class="c33"><span class="c6">El MAX7219 es un Circuito Integrado (CI) de visualizaci&oacute;n de c&aacute;todo com&uacute;n compacto, dotado de una entrada/salida serial. Esta funcionalidad facilita la interacci&oacute;n de los microprocesadores con diversos tipos de displays, como displays num&eacute;ricos de 7 segmentos de hasta 8 d&iacute;gitos, displays de barras, o matrices de 64 LEDs individuales. Para este proyecto, se elegir&aacute; la matriz de 64 LEDs individuales, tal como se muestra en la Figura 1, e implementar&aacute; el protocolo de comunicaci&oacute;n a traves de los puertos GPIO.</span></p><p class="c33 c18"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c46"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 557.63px; height: 427.22px;"><img alt="" src="images/image2.png" style="width: 557.63px; height: 427.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c32 c36 c42" id="h.2yypqdelrc9d-2"><span class="c31 c27"></span></h3><h1 class="c10" id="h.dmnut0grbj19"><span class="c37 c27">Diagrama de estado de MEF.</span></h1><p class="c33"><span class="c6">Como se muestra en la Figura 2, que representa el Modelo de Estados Finitos (MEF) del juego, este modelo se inicializa en el estado SET, donde se definir&aacute;n los par&aacute;metros iniciales, como el tiempo de espera en cada estado (denominado t=1 en la figura). Tras esto, se pasa al estado A durante un tiempo (condici&oacute;n &nbsp;t = 1), luego al estado B, y posteriormente al estado C, antes de volver al estado A, y as&iacute; sucesivamente.</span></p><p class="c33"><span class="c6">Este ciclo de transiciones A &rArr; B, B &rArr; C, C &rArr; A continuar&aacute; de manera repetitiva. La &uacute;nica forma de interrumpir este ciclo es a trav&eacute;s de la presi&oacute;n del bot&oacute;n. Dependiendo del estado en el que se encuentre el sistema en ese momento, se pasar&aacute; al estado GOOD o BAD. El estado GOOD se alcanzar&aacute; si el sistema se encuentra en el estado C en el momento de la presi&oacute;n, mientras que el estado BAD ser&aacute; el resultado si el sistema se encuentra en los estados A o B, tal como se indica en el modelo MEF.</span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.17px; height: 414.22px;"><img alt="" src="images/image1.png" style="width: 503.17px; height: 414.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><a id="t.6e94ad8504fe8f9d3c6068e8127cce8b7b61b53a"></a><a id="t.0"></a><table class="c25"><tr class="c43"><td class="c29" colspan="1" rowspan="1"><p class="c22"><span class="c27 c19">Estado</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c22"><span class="c27 c19">Descripci&oacute;n del Estado</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c22"><span class="c19 c27">Acci&oacute;n sobre la Pantalla (Actuador)</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c22"><span class="c8">SET</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Momento en que se muestra &nbsp;el tiempo &quot;delay p&quot; de espera para los estados A, B y C. Tras un tiempo &quot;delay ini&quot;, pasa al estado A y se da inicio a la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra S</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">A</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado B. En caso de presionar el bot&oacute;n, se pasa al estado BAD, indicando que se ha perdido la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra A</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">B</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado C. En caso de presionar el pulsador, se pasa al estado BAD, indicando que se ha perdido la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra B</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">C</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Si no se presiona el pulsador, se espera un tiempo &quot;delay p&quot; para pasar al estado A. En caso de presionar el bot&oacute;n, se pasa al estado GOOD, indicando que se ha ganado la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra C</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">GOOD</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Estado que indica al jugador que ha ganado la partida. Se mantendr&aacute; durante un tiempo &quot;delay 2&quot; y luego pasar&aacute; al estado SET, donde se comenzar&aacute; nuevamente la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra G</span></p></td></tr><tr class="c34"><td class="c29" colspan="1" rowspan="1"><p class="c2"><span class="c8">BAD</span></p></td><td class="c1" colspan="1" rowspan="1"><p class="c13"><span class="c8">Estado que indica al jugador que ha perdido la partida. Se mantendr&aacute; durante un tiempo &quot;delay 2&quot; y luego pasar&aacute; al estado SET, donde se comenzar&aacute; nuevamente la partida.</span></p></td><td class="c38" colspan="1" rowspan="1"><p class="c13"><span class="c8">Imprime letra B</span></p></td></tr></table><h1 class="c10" id="h.uxkwoy6zeovn"><span class="c27 c37">Componentes de hardware</span></h1><p class="c33"><span class="c6">La Figura 3 muestra los componentes de hardware que conforman el proyecto. En la parte superior, se presenta la matriz de LEDs 8x8 junto al Circuito Integrado (CI) MAX7219.</span></p><p class="c33"><span class="c6">M&aacute;s abajo, se ilustra la placa de desarrollo con el CI STM32-F429ZI, sus puertos de entrada/salida y de energ&iacute;a. Adicionalmente, se destaca un bot&oacute;n en la placa, un interruptor que ser&aacute; empleado para controlar los cambios de estado y, por consiguiente, lo que se muestra en la pantalla.</span></p><p class="c33"><span class="c6">Finalmente, se indican las conexiones entre ambos m&oacute;dulos: la de poder como +5V (cable rojo), tierra (GND, cable negro), y los cables dedicados a la comunicaci&oacute;n. Estos &uacute;ltimos incluyen: MOSI-CIN (cable amarillo), Cable Select (CS-CSS, cable verde), y Cable de Datos (MOSI-DIN, cable amarillo). Todo esto se alinea con las especificaciones t&eacute;cnicas del CI MAX7219 y las configuraciones de la placa de desarrollo.</span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c22"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 222.93px; height: 460.22px;"><img alt="" src="images/image3.png" style="width: 222.93px; height: 460.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c22"><span class="c6">Figura 3 Diagrama que muestra de manera esquem&aacute;tica los m&oacute;dulos empleados para el proyecto</span></p><h3 class="c32 c36" id="h.2yypqdelrc9d-3"><span><br></span><hr style="page-break-before:always;display:none;"></h3><h1 class="c10" id="h.7n05wo62as87"><span>Definici&oacute;n de los m&oacute;dulos de programa.</span></h1><a id="t.8ad3901016215bf902dfeeb3636af655fad35ee4"></a><a id="t.1"></a><table class="c25"><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c22"><span class="c0">Implementaci&oacute;n</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipos</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_MEF.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_MEF.c</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Gestiona los estados del juego de acuerdo con el Modelo de Estados Finitos (MEF) definido.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_Led.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_Led.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Encargado de enviar los estados actuales de la MEF a la pantalla de LED.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_UART.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">App_UART.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Facilita el env&iacute;o de eventos al terminal serial (opcional).</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_debounce.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_debounce.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Implementa la verificaci&oacute;n de flancos de se&ntilde;ales para evitar rebotes al utilizar el pulsador.</span></p></td></tr><tr class="c24"><td class="c39" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_delay.c</span></p></td><td class="c23" colspan="1" rowspan="1"><p class="c5"><span class="c7 c19">API_delay.h</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c5"><span class="c6">Define los intervalos de tiempo durante los cuales se mantendr&aacute; un determinado estado.</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><h1 class="c10" id="h.ejghyi7ruk15"><span>Prototipos de las principales funciones p&uacute;blicas y privadas de cada m&oacute;dulo definido .</span></h1><p class="c3"><span class="c6"></span></p><a id="t.0bc1b2276f5f04e90a6c28a2a7039580bada7cd7"></a><a id="t.2"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_MEF.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c45"><span class="c14">typedef enum{SET, A, B, C, GOOD, BAD} estadoMEF_t;</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Enumeraci&oacute;n de los posibles estados en el Modelo de Estados Finitos (MEF). Puede ser p&uacute;blica o privada.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">-</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void inicializarMEF(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Inicializa el MEF, definiendo los intervalos de tiempo que el sistema permanecer&aacute; en los estados A, B y C.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void actualizarMEF(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Actualiza el estado actual del MEF en funci&oacute;n del tiempo transcurrido, el estado actual y el estado del bot&oacute;n.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">char *Lee_estado();</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Identifica el flanco de la se&ntilde;al, ya sea de subida o bajada, y retorna una descripci&oacute;n correspondiente.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">Puntero a caracteres identificando flanco de subida o bajada</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><a id="t.ba91b60a5b7d04b764e31a19e4145efc2796223d"></a><a id="t.3"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_Led.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">typedef enum{} def_Led_t;</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Enumeraci&oacute;n p&uacute;blica que define las caracter&iacute;sticas de la conexi&oacute;n con la matriz de LED, como el puerto utilizado.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span>-</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void init_LED(void);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que inicializa los perif&eacute;ricos necesarios para la matriz de LED, preparando la pantalla para su uso.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void update_LED(char);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que actualiza el estado de la matriz de LED seg&uacute;n el car&aacute;cter de entrada, permitiendo la representaci&oacute;n de distintos s&iacute;mbolos.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span>char</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span>vac&iacute;o</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><a id="t.b1721f483f29c538cbefa21a64fc7e05b2476f70"></a><a id="t.4"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la App_UART.c</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t uartInit();</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n para inicializar la UART. Imprime los par&aacute;metros de configuraci&oacute;n en la terminal serie.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">-</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c7">bool_t</span><span>: </span><span class="c7">true</span><span>&nbsp;o </span><span class="c7">false</span><span class="c6">, seg&uacute;n si la conexi&oacute;n se establece o no.</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartSendString(uint8_t * pstring);</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n que recibe un puntero a un string para enviar por la UART hasta el car&aacute;cter &#39;\0&#39;. Utiliza la funci&oacute;n </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para transmitir el string.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span class="c6">: puntero al string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartSendStringSize(uint8_t * pstring, uint16_t size)</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que recibe un puntero a un string y un entero con la cantidad de caracteres que debe enviar por la UART. Utiliza </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para enviar.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span>: puntero al string, </span><span class="c7">uint16_t size</span><span class="c6">: tama&ntilde;o del string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c9" colspan="1" rowspan="1"><p class="c5"><span class="c14">void uartReceiveStringSize(uint8_t * pstring, uint16_t size)</span></p></td><td class="c15" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que recibe un puntero a un string y un entero con la cantidad de caracteres que debe recibir por la UART. Utiliza </span><span class="c7">HAL_UART_Transmit(...)</span><span class="c6">&nbsp;para recibir.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">uint8_t * pstring</span><span>: puntero al string, </span><span class="c7">uint16_t size</span><span class="c6">: tama&ntilde;o del string</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">vacio </span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><h2 class="c47" id="h.5qvvrwkfawvu"><span class="c27 c48"></span></h2><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><a id="t.69f8c30c8e72e92cf7c70ced6e3f8b279e808d81"></a><a id="t.5"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la API_debounce.c</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t readKey();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que lee una variable interna y devuelve si la tecla fue presionada. Si retorna </span><span class="c7">true</span><span>, reinicia el estado de la variable (lo establece en </span><span class="c7">false</span><span class="c6">).</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c7">bool_t</span><span>: estado de la tecla (</span><span class="c7">true</span><span>&nbsp;si fue presionada, </span><span class="c7">false</span><span class="c6">&nbsp;en caso contrario).</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">void debounceFSM_init()</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que inicializa la m&aacute;quina de estados finita (FSM) para el control de rebote, estableciendo el estado inicial.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c11"><span class="c7">void debounceFSM_update(delaydebounce_t* delay)</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que actualiza la FSM para el control de rebote. Lee las entradas, eval&uacute;a las condiciones de transici&oacute;n de acuerdo con el estado actual de la FSM y actualiza el estado y las salidas correspondientes.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">delaydebounce_t* delay</span><span class="c6">: puntero a la instancia de retardo.</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">char *readStatus();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que identifica si se trata de un flanco de subida o de bajada, lo cual es esencial para detectar cambios de estado en una se&ntilde;al.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c3"><span class="c6"></span></p></td></tr></table><p class="c3"><span class="c6"></span></p><h3 class="c32 c36" id="h.jvai5obof5db"><span class="c27 c31"></span></h3><p class="c3"><span class="c6"></span></p><a id="t.584bfb26729d0f55d99d7016df672e19f3de7c78"></a><a id="t.6"></a><table class="c25"><tr class="c26"><td class="c12" colspan="4" rowspan="1"><p class="c5"><span class="c0">Tabla de la API_delay.c</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c22"><span class="c0">Prototipo</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c22"><span class="c0">Descripci&oacute;n</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c35"><span class="c0">Entrada</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c35"><span class="c0">Retorna</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">bool_t readKey();</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span>Funci&oacute;n p&uacute;blica que lee una variable interna y devuelve si la tecla fue presionada. Si retorna </span><span class="c7">true</span><span>, reinicia el estado de la variable (lo establece en </span><span class="c7">false</span><span class="c6">).</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c7">bool_t</span><span>: estado de la tecla (</span><span class="c7">true</span><span>&nbsp;si fue presionada, </span><span class="c7">false</span><span class="c6">&nbsp;en caso contrario).</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c5"><span class="c14">void debounceFSM_init()</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que inicializa la m&aacute;quina de estados finita (FSM) para el control de rebote, estableciendo el estado inicial.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c5"><span class="c6">Vac&iacute;o</span></p></td></tr><tr class="c24"><td class="c17" colspan="1" rowspan="1"><p class="c11"><span class="c14">void debounceFSM_update(delaydebounce_t* delay)</span></p></td><td class="c21" colspan="1" rowspan="1"><p class="c5"><span class="c6">Funci&oacute;n que actualiza la FSM para el control de rebote. Lee las entradas, eval&uacute;a las condiciones de transici&oacute;n de acuerdo con el estado actual de la FSM y actualiza el estado y las salidas correspondientes.</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c11"><span class="c7">delaydebounce_t* delay</span><span class="c6">: puntero a la instancia de retardo.</span></p></td><td class="c30" colspan="1" rowspan="1"><p class="c11"><span class="c6">Vac&iacute;o</span></p></td></tr></table><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p><p class="c3"><span class="c6"></span></p></body></html>